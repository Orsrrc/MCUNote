# 51单片机

intel开发的8051单片机内核，

STC89C52单片机

- 所属系列：51单片机系列

- 公司：STC公司

- 位数：8位

-	IRAM:512字节

-	ROM: 8K （Flash）

- 工作频率：12MHz（本开发板使用）

在电路原理图中，VCC代表电源正极

GND代表电源的负极

![image-20260104120409533](./MCU.assets/image-20260104120409533.png)

复位电路，即程序代码执行到某一条以后想要重新重头开始执行，就需要外部接一个复位电路。

![image-20260104120518805](./MCU.assets/image-20260104120518805.png)

注意，在单片机的设计图中有一个圆形缺口的位置，这代表了单片机的正反面

![image-20260104120736838](./MCU.assets/image-20260104120736838.png)

在拆卸单片机时，要注意正面（缺口）面朝上，并且正向摆放，防止正负电极反向，导致短路

51单片机有4个8位的I/O口，对应的控制寄存器为：

| 寄存器 | 控制端口  | 功能说明           |
| ------ | --------- | ------------------ |
| **P0** | P0.0-P0.7 | 控制端口0的8个引脚 |
| **P1** | P1.0-P1.7 | 控制端口1的8个引脚 |
| **P2** | P2.0-P2.7 | 控制端口2的8个引脚 |
| **P3** | P3.0-P3.7 | 控制端口3的8个引脚 |



## 点亮LED

LED 引脚未修建时  长脚为正极 短脚为负极

![image-20260104123229931](./MCU.assets/image-20260104123229931.png)

![image-20260104124221942](./MCU.assets/image-20260104124221942.png)

电路板上 电阻的读数方式

例如 102 = 10 + 00 == 1000

473  = 47 + 000 == 47000

即最后一位表示倍率，47n 表示47*10^n^

于是对于LED灯的点亮就变成了如何控制对应的接口输出高电平还是低电平

例如当P20接口输出低电平时，形成电流通过D1就会点亮D1，如果P20输出高电平就会有两边正极，不会形成电流，D1不亮。

在电路中对于高电平5V，低电平0V的电路，定义为TTL电平

通过编写程序，CPU解析程序代码以后发出信号，到驱动器中，驱动硬件电路形成高低电平。

通过电路图我们可以看到，与LED相连的引脚为P2.0 即通过P2寄存器来控制输出高低电平。

例如我们想点亮P20线路上的LED灯，那么就需要输出11111110 转换为16进制为0xFE



我们通过KeilProject编译器编译以后，在选择单片机类型以后可以右键插入头文件，该头文件根据选择的单片机型号不同而改变，并且要在项目设置中，点击output，然后输出.hex文件

**.hex文件是 Intel HEX 格式的文件**，是一种文本格式的十六进制文件，用于存储单片机的机器代码和程序数据。

然后通过开发版的烧录工具，烧录到开发板中。

```c++
#include <REGX52.H>

void main()
{
	P2=0xFE;
  while(1){}
}
```

对于单片机而言，由于里面通常只运行一个程序，因此会不断地循环执行该程序，不断地删除然后创建一个进程，所消耗的资源较大，因此我们可以让程序一直运行，从而减少消耗

LED灯闪烁

由于CPU频率有12Mhz，而如果我们只是单纯的切换P2的内容，只会使得LED闪烁过快，而人眼无法分辨，因此我们需要给LED灯添加延时

通过开发板给的软件，我们可以获取到对应的计算延时代码

![image-20260104131317639](./MCU.assets/image-20260104131317639.png)

# STM32单片机

## 库函数的基本使用方法

在.h文件里面有库函数的定义（通常在最底部），然后我们可以跳转到对应的定义部分，根据注释来查看库函数用法

## GPIO

- （General Purpose Input Output) 通用输入输出口

![image-20260104134934517](./MCU.assets/image-20260104134934517.png)

上拉电阻与下拉电阻，当引脚悬空时（没有外部输入），开发板非常容易受到外界的干扰，此时需要加入上拉或者下拉电阻。当Vdd接通时，表示默认高电平，当Vss接通时默认为低电平。

![image-20260104135004245](./MCU.assets/image-20260104135004245.png)

施密特触发器（图中为肖特基触发器，图片错误），这里的触发器保证了不会因为输入信号的失真导致信号出现错误。施密特触发器，它定义了一个阈值，该阈值分为最高阈值和最低阈值。当输入的信号高于或者低于阈值时才会切换信号。例如，当信号出现失真时，如果没有该触发器，输出的信号就会在高低电平中反复切换，而有了该触发器以后，该只有高于阈值或者低于阈值的信号才会触发电平的切换。

这样可以有效的避免了因为信号波动而导致的信号抖动现象



输出信号模块

通过Mos管控制信号输出

推挽输出模式

- P-MOS N-MOS均有效

-	数据寄存器为1时，上管导通，下管断开，输出直接接到VDD，表示输出高电平

-	数据寄存器为0时，下管导通，输出直接接到VSS，表示输出低电平

- 在推挽输出模式下，STM32对IO口具有绝对的控制权，高低电平都由STM32决定

开漏输出模式下，P-MOS无效，只有N-MOS工作

- 数据寄存器为1时，下管断开，此时上下管均无输出，输出断开，此时为高阻模式
- 数据寄存器为0时，下管导通，输出直接接到VSS，表示输出低电平
- 开漏输出可以用于通信引脚，或者用于兼容一些5V电平的设备

输入模式

- 此时MOS管都无效，即输出关闭

![image-20260104170033359](./MCU.assets/image-20260104170033359.png)

当要使用ADC的时候，引脚直接设置为模拟输入模式即可

单片机或者芯片，都使用了高电平弱驱动，低电平强驱动的规则，因此不能采用STM32连接LED的负极的方法

![image-20260104171348197](./MCU.assets/image-20260104171348197.png)

PNP的三级管最好与输入电源端（正极）相连

NPN的三极管与输出电源端（负极）相连

## 新建KeliSTM32工程

![image-20260104172246802](./MCU.assets/image-20260104172246802.png)

在工程文件中新建Start、Library、User三个文件夹用于导入库文件

在库中找到下面的文件

![image-20260104172432950](./MCU.assets/image-20260104172432950.png)

复制到Start文件夹下

![image-20260104172524710](./MCU.assets/image-20260104172524710.png)

复制到start文件夹下

![image-20260104172612682](./MCU.assets/image-20260104172612682.png)

复制到start文件夹下

Start文件夹下的程序

![image-20260104172635081](./MCU.assets/image-20260104172635081.png)

打开src文件 将文件放入到library文件夹中

![image-20260104172853725](./MCU.assets/image-20260104172853725.png)

将inc文件夹下的头文件也放到library文件夹下

![image-20260105150556599](./MCU.assets/image-20260105150556599.png)

将Template文件夹下面的代码复制到User文件夹里面

![image-20260105150322540](./MCU.assets/image-20260105150322540.png)

点击图标为三个箱子的按钮，添加三个组 在Start里面添加对应的文件

![image-20260105150835946](./MCU.assets/image-20260105150835946.png)

在library组下添加library文件夹中的所有文件

![image-20260105151020392](./MCU.assets/image-20260105151020392.png)

在User组里面添加对应文件

![image-20260105151112964](./MCU.assets/image-20260105151112964.png)



点击魔术棒按钮，点击C++，在includepath文件索引 将三个文件夹添加进去

![image-20260105151609873](./MCU.assets/image-20260105151609873.png)



定义一个字符串USE_STDPERIPH_DRIVER

![image-20260105151916858](./MCU.assets/image-20260105151916858.png)



在Debug下选择ST-Link作为调试器

![image-20260105152837511](./MCU.assets/image-20260105152837511.png)

![image-20260105152530131](./MCU.assets/image-20260105152530131.png)



操作GPIO

- 使用RCC开启GPIO的时钟
- 使用GPIO_Init函数初始化GPIO
- 使用输出或者输入的函数控制GPIO口



在RCC库函数里面可以看到对应的定义

![image-20260105153452873](./MCU.assets/image-20260105153452873.png)



GPIO库函数定义

![image-20260105153707281](./MCU.assets/image-20260105153707281.png)

在里面可以找到一个枚举类型，用于指定GPIO的工作模式

![image-20260105153931491](./MCU.assets/image-20260105153931491.png)



### 点亮LED

设置外设的0号引脚为推挽输出、50MHZ的速度

![image-20260105154128257](./MCU.assets/image-20260105154128257.png)



![image-20260105154518714](./MCU.assets/image-20260105154518714.png)

当设置端口为低电平时，电路接通，LED灯点亮，反之端口设置为高电平的时候，LED保持熄灭

### LED灯闪烁

其逻辑就是输出低电平，延时，输出高电平，延时，输出低电平…..

延时模块尝尝会使用，因此我们可以写一个模块，以后直接调用就行。

GPIO设置为开漏模式

具体代码

![image-20260105160542372](./MCU.assets/image-20260105160542372.png)

### LED流水灯

此时我们需要接入八个LED灯，因此需要用到GPIO的0~7号端口

可以看到，对于端口的初始化，对应为二进制的每个位值，因此如果我们想一次初始化多个接口可以将其进行位与操作

![image-20260105160955632](./MCU.assets/image-20260105160955632.png)

其中GPIO_Pin_All代表了0xFF，即十六个端口全部设置为推挽输出模式

设置GPIO端口![image-20260105161410226](./MCU.assets/image-20260105161410226.png)



流水灯延时部分，其中由于低电平点亮，因此采用取反操作，点亮对应的LED灯

![image-20260105161633647](./MCU.assets/image-20260105161633647.png)



### 蜂鸣器

注意A14 A15 PB3这三个端口是用于调试的端口，如果想要用作普通端口还需要进行设置。

![image-20260105161936033](./MCU.assets/image-20260105161936033.png)



端口输出模式设置

![image-20260105162211757](./MCU.assets/image-20260105162211757.png)



同理，低电平接通，高电平阻断

![image-20260105162332152](./MCU.assets/image-20260105162332152.png)



## GPIO输入

### 按键

- 按下导通
- 松手断开
- 按键抖动
  - 由于按键内部使用的是机械式弹簧片来进行通断，所以在按下和松手的瞬间会伴随有一连串的抖动

![image-20260105164341974](./MCU.assets/image-20260105164341974.png)

为了避免按下一个按键，单片机却接收到多个信号的现象，我们需要将信号进行过滤



### 传感器模块

传感器元件（光敏电阻/热敏电阻/红外接收管等）的电阻会随外界模拟量的变化而变化，通过与定值电阻分压即可得到模拟电压输出，再通过电压比较器进行二值化即可得到数字电压输出。

电路图中，一段接电路，一端接地的电容可以考虑是否用于滤波，使得电压输出更加的平滑。

![image-20260105165455148](./MCU.assets/image-20260105165455148.png)

按键模块，硬件电路

![image-20260112161641279](./MCU.assets/image-20260112161641279.png)



![image-20260112162657649](./MCU.assets/image-20260112162657649.png)

在单片机中，不同的机器中，同一关键字对应的数据位数可能不同，在c语言的标准库中(stdint)对数据类型进行了重定义，ST公司也对数据进行了重定义，其中对于char来说，在单片机中大部分使用的情况是用于存储整数，在重定义时用于指定位数。

![image-20260112163029324](./MCU.assets/image-20260112163029324.png)

### 代码

将LED代码封装到对应的LED.c LED.h文件里面，这里的Hardware文件夹需要自行手动新建一个文件夹，然后将其导入进去。

![image-20260112165627209](./MCU.assets/image-20260112165627209.png)

LED.c初始化代码，调用该函数，LED灯亮起

![image-20260112165349399](./MCU.assets/image-20260112165349399.png)

定义LED开关函数

![image-20260112170109903](./MCU.assets/image-20260112170109903.png)

按键模块初始化  Key.c Key.h，当需要读取数据的输入时，GPIO的输出频率这个参数就没有用了。

![image-20260112170447498](./MCU.assets/image-20260112170447498.png)



读取按钮输入数据函数

![image-20260112171152175](./MCU.assets/image-20260112171152175.png)



GPIO_ReadOutputDataBit()函数，用于读取电平的输出状态，然后根据输出的状态取反，即可实现按下灯亮，弹起灯灭。

![image-20260112171517053](./MCU.assets/image-20260112171517053.png)



蜂鸣器（用电器）的初始化与LED相同，但是要注意端口是否有错。这种一个信号响，另一个信号静音的设备，采用推挽输出即可。



光敏传感器函数封装

![image-20260112172649740](./MCU.assets/image-20260112172649740.png)

初始化以后，读取传感器的信号实现蜂鸣器的开关。
